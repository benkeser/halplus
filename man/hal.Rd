% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hal.R
\name{hal}
\alias{hal}
\title{hal}
\usage{
hal(Y, X, newX = NULL, verbose = FALSE, obsWeights = rep(1, length(Y)),
  nfolds = ifelse(length(Y) <= 100, 20, 10), nlambda = 100, useMin = TRUE,
  debug = TRUE, parallel = FALSE, family, ...)
}
\arguments{
\item{Y}{A \code{numeric} of outcomes}

\item{X}{A \code{data.frame} of predictors}

\item{newX}{Optional \code{data.frame} on which to return predicted values}

\item{verbose}{A \code{boolean} indicating whether to print output on functions progress}

\item{obsWeights}{Optional \code{vector} of observation weights to be passed to \code{cv.glmnet}}

\item{nfolds}{Number of CV folds passed to \code{cv.glmnet}}

\item{nlambda}{Number of lambda values to search across in \code{cv.glmnet}}

\item{useMin}{Option passed to \code{cv.glmnet}, use minimum risk lambda or 1se lambda (more
penalization)}

\item{debug}{For benchmarking. Setting to \code{TRUE} will run garbage collection to
improve the accuracy of memory monitoring}

\item{parallel}{A boolean indicating whether to use a parallel backend, if possible}

\item{family}{binomial() or gaussian()}

\item{...}{Not currently used}
}
\description{
The highly adaptive lasso fitting function. This function takes a matrix of predictor values
(which can be binary or continuous) and converts it into a set of indicator basis functions
that perfectly fit the data. The function then uses cross-validated lasso (via the \code{glmnet}
package) to select basis functions. The resulting fit is called the highly adaptive lasso.
The process of creating the indicator basis functions can be extremely time and memory intensive
as it involves creating n(2^d - 1) basis functions, where n is the number of observations
and d the number of covariates. The function also must subsequently search over basis functions
for those that are duplicated and store the results. Future implementations will attempt to
streamline this process to the largest extent possible; however, for the time being implementing
with values of n and d such that n(2^d - 1) > 1e7 is not recommended.
}
